{"version":3,"sources":["index.tsx"],"names":["Compressor","NativeModules","AUDIO_BITRATE","INCORRECT_INPUT_PATH","INCORRECT_OUTPUT_PATH","ERROR_OCCUR_WHILE_GENERATING_OUTPUT_FILE","DEFAULT_COMPRESS_AUDIO_OPTIONS","bitrate","quality","outputFilePath","generateFile","extension","Promise","resolve","reject","then","result","catch","error","isValidUrl","url","test","getFullFilename","path","_path","includes","length","substring","array","split","isFileNameError","filename","getFilename","fullFilename","slice","join","isRemoteMedia","getDetails","mediaFullPath","extesnion","Error","mediaInfo","JSON","parse","mediaInformation","getMediaProperties","bit_rate","size","Number","format","e","checkUrlAndOptions","options","defaultResult","isCorrect","message","undefined"],"mappings":"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","sourcesContent":["import { NativeModules } from 'react-native';\nconst { Compressor } = NativeModules;\nexport const AUDIO_BITRATE = [256, 192, 160, 128, 96, 64, 32];\ntype qualityType = 'low' | 'medium' | 'high';\nconst INCORRECT_INPUT_PATH = 'Incorrect input path. Please provide a valid one';\nconst INCORRECT_OUTPUT_PATH =\n  'Incorrect output path. Please provide a valid one';\nconst ERROR_OCCUR_WHILE_GENERATING_OUTPUT_FILE =\n  'An error occur while generating output file';\ntype audioCompresssionType = {\n  bitrate?: number;\n  quality: qualityType;\n  outputFilePath?: string | undefined | null;\n};\n\nexport type defaultResultType = {\n  outputFilePath: string | undefined | null;\n  isCorrect: boolean;\n  message: string;\n};\n\nexport const DEFAULT_COMPRESS_AUDIO_OPTIONS: audioCompresssionType = {\n  bitrate: 96,\n  quality: 'medium',\n  outputFilePath: '',\n};\n\nexport type AudioType = {\n  compress(value: string, options?: audioCompresssionType): Promise<string>;\n};\n\nconst generateFile: any = (extension: string) => {\n  return new Promise((resolve, reject) => {\n    Compressor.generateFile(extension)\n      .then((result: any) => resolve('file://' + result))\n      .catch((error: any) => reject(error));\n  });\n};\n\nconst isValidUrl = (url: string) =>\n  /^(?:\\w+:)?\\/\\/([^\\s\\.]+\\.\\S{2}|localhost[\\:?\\d]*)\\S*$/.test(url);\n\nconst getFullFilename = (path: string | null) => {\n  if (typeof path === 'string') {\n    let _path = path;\n\n    // In case of remote media, check if the url would be valid one\n    if (path.includes('http') && !isValidUrl(path)) {\n      return INCORRECT_INPUT_PATH;\n    }\n\n    // In case of url, check if it ends with \"/\" and do not consider it furthermore\n    if (_path[_path.length - 1] === '/')\n      _path = _path.substring(0, path.length - 1);\n\n    const array = _path.split('/');\n    return array.length > 1 ? array[array.length - 1] : INCORRECT_INPUT_PATH;\n  }\n  return INCORRECT_INPUT_PATH;\n};\n\nconst isFileNameError = (filename: string) => {\n  return filename === INCORRECT_INPUT_PATH;\n};\n\nconst getFilename = (path: string | null) => {\n  const fullFilename = getFullFilename(path);\n  if (!isFileNameError(fullFilename)) {\n    const array = fullFilename.split('.');\n    return array.length > 1 ? array.slice(0, -1).join('') : array.join('');\n  }\n  return fullFilename;\n};\n\nconst isRemoteMedia = (path: string | null) => {\n  return typeof path === 'string' ? path.split(':/')[0].includes('http') : null;\n};\n\nexport const getDetails = (\n  mediaFullPath: string,\n  extesnion: 'mp3' | 'mp4' = 'mp3'\n): Promise<any | null> => {\n  return new Promise(async (resolve, reject) => {\n    try {\n      // Since we used \"-v error\", a work around is to call first this command before the following\n      const result: any = {};\n      if (result !== 0) {\n        throw new Error('Failed to execute command');\n      }\n\n      // get the output result of the command\n      // example of output {\"programs\": [], \"streams\": [{\"width\": 640,\"height\": 360}], \"format\": {\"size\": \"15804433\"}}\n      let mediaInfo: any = await {};\n      mediaInfo = JSON.parse(mediaInfo);\n\n      // execute second command\n      const mediaInformation: any = await {};\n\n      // treat both results\n      mediaInformation.filename = getFilename(mediaFullPath);\n      mediaInformation.bitrate = mediaInformation.getMediaProperties().bit_rate;\n      mediaInformation.extension = extesnion;\n      mediaInformation.isRemoteMedia = isRemoteMedia(mediaFullPath);\n      mediaInformation.size = Number(mediaInfo.format.size);\n\n      resolve(mediaInformation);\n    } catch (e) {\n      reject(e);\n    }\n  });\n};\n\nexport const checkUrlAndOptions = async (\n  url: string,\n  options: audioCompresssionType\n): Promise<defaultResultType> => {\n  if (!url) {\n    throw new Error(\n      'Compression url is empty, please provide a url for compression.'\n    );\n  }\n  const defaultResult: defaultResultType = {\n    outputFilePath: '',\n    isCorrect: true,\n    message: '',\n  };\n\n  // Check if output file is correct\n  let outputFilePath: string | undefined | null;\n  try {\n    // use default output file\n    // or use new file from cache folder\n    if (options.outputFilePath) {\n      outputFilePath = options.outputFilePath;\n      defaultResult.outputFilePath = outputFilePath;\n    } else {\n      outputFilePath = await generateFile('mp3');\n      defaultResult.outputFilePath = outputFilePath;\n    }\n    if (outputFilePath === undefined || outputFilePath === null) {\n      defaultResult.isCorrect = false;\n      defaultResult.message = options.outputFilePath\n        ? INCORRECT_OUTPUT_PATH\n        : ERROR_OCCUR_WHILE_GENERATING_OUTPUT_FILE;\n    }\n  } catch (e) {\n    defaultResult.isCorrect = false;\n    defaultResult.message = options.outputFilePath\n      ? INCORRECT_OUTPUT_PATH\n      : ERROR_OCCUR_WHILE_GENERATING_OUTPUT_FILE;\n  } finally {\n    return defaultResult;\n  }\n};\n"]}